/**
 * These arguments were used when this file was generated. They will be automatically applied on subsequent loads
 * via the GUI or CLI. Run CLI with '--help' for additional information on how to override these arguments.
 * @cliArgs --device "F28002x" --package "80QFP" --part "F28002x_80QFP" --context "system" --product "C2000WARE@5.01.00.00"
 * @versions {"tool":"1.19.0+3426"}
 */

/**
 * Import the modules used in this configuration.
 */
const analog           = scripting.addModule("/driverlib/analog.js", {}, false);
const analog1          = analog.addInstance();
const asysctl          = scripting.addModule("/driverlib/asysctl.js");
const epwm             = scripting.addModule("/driverlib/epwm.js", {}, false);
const epwm1            = epwm.addInstance();
const epwm2            = epwm.addInstance();
const gpio             = scripting.addModule("/driverlib/gpio.js", {}, false);
const gpio1            = gpio.addInstance();
const gpio2            = gpio.addInstance();
const gpio3            = gpio.addInstance();
const gpio4            = gpio.addInstance();
const inputxbar_input  = scripting.addModule("/driverlib/inputxbar_input.js", {}, false);
const inputxbar_input1 = inputxbar_input.addInstance();
const inputxbar_input2 = inputxbar_input.addInstance();
const sync             = scripting.addModule("/driverlib/sync.js");

/**
 * Write custom configuration values to the imported modules.
 */
analog1.$name                           = "myANALOGPinMux0";
analog1.useCase                         = "CUSTOM";
analog1.useInterfacePins                = ["A0/C15","A1","A10/C10","A11/C0","A15/C7","A2/C9","A3/C5/VDAC","A5/C2","A7/C3"];
analog1.analog.$assign                  = "ANALOG";
analog1.analog["a0/c15Pin"].$assign     = "A0/C15";
analog1.analog.a1Pin.$assign            = "A1";
analog1.analog["a10/c10Pin"].$assign    = "A10/C10";
analog1.analog["a11/c0Pin"].$assign     = "A11/C0";
analog1.analog["a15/c7Pin"].$assign     = "A15/C7";
analog1.analog["a2/c9Pin"].$assign      = "A2/C9";
analog1.analog["a3/c5/vdacPin"].$assign = "A3/C5/VDAC";
analog1.analog["a5/c2Pin"].$assign      = "A5/C2";
analog1.analog["a7/c3Pin"].$assign      = "A7/C3";

asysctl.analogReference        = "INTERNAL";
asysctl.analogReferenceVoltage = "1P65";

epwm1.epwmTimebase_hsClockDiv                                  = "EPWM_HSCLOCK_DIVIDER_1";
epwm1.epwmEventTrigger_enableInterrupt                         = true;
epwm1.epwmEventTrigger_interruptSource                         = "EPWM_INT_TBCTR_ZERO";
epwm1.epwmEventTrigger_interruptEventCount                     = "3";
epwm1.useCase                                                  = "CUSTOM";
epwm1.useInterfacePins                                         = ["EPWM#_B"];
epwm1.$name                                                    = "myEPWM4";
epwm1.epwmTimebase_periodGld                                   = true;
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_gld                 = true;
epwm1.epwmCounterCompare_enableShadowLoadModeCMPA              = false;
epwm1.epwmCounterCompare_cmpBLink                              = "EPWM_LINK_WITH_EPWM_4";
epwm1.epwmCounterCompare_enableShadowLoadModeCMPB              = false;
epwm1.epwmCounterCompare_cmpBGld                               = true;
epwm1.epwmActionQualifier_t1Source                             = "EPWM_AQ_TRIGGER_EVENT_TRIG_DCB_1";
epwm1.epwmActionQualifier_t2Source                             = "EPWM_AQ_TRIGGER_EVENT_TRIG_DCB_1";
epwm1.epwmActionQualifier_continousSwForceReloadMode           = "EPWM_AQ_SW_IMMEDIATE_LOAD";
epwm1.epwmTimebase_syncInPulseSource                           = "EPWM_SYNC_IN_PULSE_SRC_SYNCOUT_EPWM4";
epwm1.epwmActionQualifier_continousSwForceReloadModeGld        = true;
epwm1.epwmTimebase_counterMode                                 = "EPWM_COUNTER_MODE_UP";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_UP_CMPB = "EPWM_AQ_OUTPUT_LOW";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_ZERO    = "EPWM_AQ_OUTPUT_HIGH";
epwm1.epwmTimebase_period                                      = 20000;
epwm1.epwmCounterCompare_cmpB                                  = 10000;
epwm1.epwm.$assign                                             = "EPWM4";
epwm1.epwm.epwm_bPin.$assign                                   = "GPIO7";

epwm2.epwmTimebase_hsClockDiv                                  = "EPWM_HSCLOCK_DIVIDER_1";
epwm2.epwmEventTrigger_enableInterrupt                         = true;
epwm2.epwmEventTrigger_interruptSource                         = "EPWM_INT_TBCTR_ZERO";
epwm2.epwmEventTrigger_interruptEventCount                     = "3";
epwm2.useCase                                                  = "CUSTOM";
epwm2.useInterfacePins                                         = ["EPWM#_B"];
epwm2.epwmTimebase_periodGld                                   = true;
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_B_gld                 = true;
epwm2.epwmCounterCompare_enableShadowLoadModeCMPA              = false;
epwm2.epwmCounterCompare_cmpBLink                              = "EPWM_LINK_WITH_EPWM_4";
epwm2.epwmCounterCompare_enableShadowLoadModeCMPB              = false;
epwm2.epwmCounterCompare_cmpBGld                               = true;
epwm2.epwmActionQualifier_t1Source                             = "EPWM_AQ_TRIGGER_EVENT_TRIG_DCB_1";
epwm2.epwmActionQualifier_t2Source                             = "EPWM_AQ_TRIGGER_EVENT_TRIG_DCB_1";
epwm2.epwmActionQualifier_continousSwForceReloadMode           = "EPWM_AQ_SW_IMMEDIATE_LOAD";
epwm2.epwmTimebase_syncInPulseSource                           = "EPWM_SYNC_IN_PULSE_SRC_SYNCOUT_EPWM4";
epwm2.epwmActionQualifier_continousSwForceReloadModeGld        = true;
epwm2.$name                                                    = "myEPWM3";
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_UP_CMPB = "EPWM_AQ_OUTPUT_HIGH";
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_PERIOD  = "EPWM_AQ_OUTPUT_LOW";
epwm2.epwmTimebase_counterMode                                 = "EPWM_COUNTER_MODE_UP";
epwm2.epwmTimebase_period                                      = 20000;
epwm2.epwmCounterCompare_cmpB                                  = 10000;
epwm2.epwm.$assign                                             = "EPWM3";
epwm2.epwm.epwm_bPin.$assign                                   = "GPIO5";

gpio1.$name                      = "FLTN_in";
gpio1.padConfig                  = "PULLUP";
gpio1.useInterrupt               = true;
gpio1.gpioPin.$assign            = "GPIO4";
gpio1.xint.enableInt             = true;
gpio1.xint.registerInterrupts    = true;
gpio1.xint.xInt.interruptHandler = "gbl_flt_ISR";
gpio1.xint.xInt.enableInterrupt  = true;

gpio2.$name           = "ENB_out";
gpio2.direction       = "GPIO_DIR_MODE_OUT";
gpio2.gpioPin.$assign = "GPIO6";

gpio3.padConfig         = "OD";
gpio3.direction         = "GPIO_DIR_MODE_OUT";
gpio3.$name             = "RDY_out";
gpio3.writeInitialValue = true;
gpio3.initialValue      = 1;
gpio3.gpioPin.$assign   = "GPIO24";

gpio4.$name           = "ENA_out";
gpio4.direction       = "GPIO_DIR_MODE_OUT";
gpio4.padConfig       = "PULLUP";
gpio4.gpioPin.$assign = "GPIO32";

inputxbar_input1.$name         = "myINPUTXBARINPUT0";
gpio1.xint.inputxbar           = inputxbar_input1;
inputxbar_input1.inputxbarGpio = "GPIO4";

inputxbar_input2.$name          = "myINPUTXBARINPUT1";
inputxbar_input2.inputxbarInput = "XBAR_INPUT5";
inputxbar_input2.inputxbarGpio  = "GPIO33";
